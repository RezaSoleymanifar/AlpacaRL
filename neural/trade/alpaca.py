from __future__ import annotations
from abc import ABC, abstractmethod
from torch import nn
from typing import TYPE_CHECKING, List
import numpy as np

from neural.common.constants import PATTERN_DAY_TRADER_MINIMUM_NET_WORTH
from neural.common.exceptions import TradeConstraintViolationError
from neural.client.alpaca import AlpacaClient, AbstractTradeClient
from neural.core.data.enums import DatasetMetadata
from neural.meta.env.pipe import AbstractPipe

if TYPE_CHECKING:
    from neural.meta.env.base import TradeMarketEnv



class AbstractTrader(ABC):

    """
    Abstract base class for defining a trading agent that can execute orders based on model actions.
    """

    def __init__(self,
        client: AbstractTradeClient,
        model: nn.Module,
        pipe: AbstractPipe,
        dataset_metadata: DatasetMetadata):

        """
        Initializes an AbstractTrader object.

        Args:
            client (AbstractClient): An instance of the client to connect to the trading environment.
            model (nn.Module): A PyTorch model used to generate actions for the trader.
            pipe (AbstractPipe): An instance of the data pipe used to feed data to the model.
            dataset_metadata (DatasetMetadata): Metadata for the dataset being used for training and validation.
        """

        self.client = client
        self.model = model
        self.pipe = pipe
        self.dataset_metadata = dataset_metadata

        self.symbols = self.dataset_metadata.symbols
        self._initial_cash = None
        self._cash = None
        self._asset_quantities = None
        self._net_worth = None
        self._longs = None
        self._shorts = None

        return None

    @property
    @abstractmethod
    def initial_cash(self):

        """
        The initial amount of cash available to the trader.

        Raises:
            NotImplementedError: This property must be implemented by a subclass.
        """

        raise NotImplementedError
        
    @property
    @abstractmethod
    def cash(self):

        """
        The current amount of cash available to the trader.

        Raises:
            NotImplementedError: This property must be implemented by a subclass.
        """

        raise NotImplementedError
    
    @property
    @abstractmethod
    def asset_quantities(self):

        """
        The current quantity of each asset held by the trader.

        Raises:
            NotImplementedError: This property must be implemented by a subclass.
        """

        raise NotImplementedError

    @property
    @abstractmethod
    def positions(self):

        """
        The current positions of each asset held by the trader.

        Raises:
            NotImplementedError: This property must be implemented by a subclass.
        """

        raise NotImplementedError    

    @property
    @abstractmethod
    def net_worth(self):

        """
        The current net worth of the trader.

        Raises:
            NotImplementedError: This property must be implemented by a subclass.
        """

        raise NotImplementedError
    
    @property
    @abstractmethod
    def longs(self):

        """
        The current long positions held by the trader.

        Raises:
            NotImplementedError: This property must be implemented by a subclass.
        """

        raise NotImplementedError
    
    @property
    @abstractmethod
    def shorts(self):

        """
        The current short positions held by the trader.

        Raises:
            NotImplementedError: This property must be implemented by a subclass.
        """

        raise NotImplementedError
        
    # this method is responsible for starting the trading process.
    @abstractmethod
    def trade(self, *args, **kwargs):

        """
        Abstract method responsible for starting the trading process.

        Raises:
            NotImplementedError: This method must be implemented by a subclass.
        """

        raise NotImplementedError

    # takes actions from model and places relevant orders
    @abstractmethod
    def place_orders(self, actions, *args, **kwargs):

        """
        Abstract method that takes actions from the model and places relevant orders.

        Args:
            actions (np.ndarray): A 2D numpy array of actions generated by the model.

        Raises:
            NotImplementedError: This method must be implemented by a subclass.
        """

        raise NotImplementedError



class AlpacaTraderTemplate(AbstractTrader):

    """
    A template implementation of the AbstractTrader class for trading with the Alpaca API.
    """


    def __init__(self,
        client: AlpacaClient,
        model: nn.Module,
        pipe: AbstractPipe,
        dataset_metadata: DatasetMetadata):

        """
        Initializes an AlpacaTraderTemplate object.

        Args:
            client (AlpacaMetaClient): An instance of the Alpaca client to connect to the trading environment.
            model (nn.Module): A PyTorch model used to generate actions for the trader.
            pipe (AbstractPipe): An instance of the data pipe used to feed data to the model.
            dataset_metadata (DatasetMetadata): Metadata for the dataset being used for training and validation.
        """

        super().__init__(
            client,
            model,
            pipe,
            dataset_metadata)


    @property
    def initial_cash(self):

        """
        The initial amount of cash available to the trader.

        Returns:
            float: The initial amount of cash available to the trader.
        """

        if self._initial_cash is None:
            self._initial_cash = self.client.cash

        return self._initial_cash


    @property
    def cash(self):

        """
        The current amount of cash available to the trader.

        Returns:
            float: The current amount of cash available to the trader.
        """

        self._cash = self.client.account.cash
        return self._cash


    @property
    def asset_quantities(self):

        """
        The current quantity of each asset held by the trader.

        Returns:
            List[float]: A list of the current quantity of each asset held by the trader.
        """

        symbols = self.dataset_metadata.symbols
        positions = self.client.positions
        asset_quantities = []

        for symbol in symbols:
            row = positions[positions['symbol'] == symbol]

            if not row.empty:
                row_data = row.iloc[0]
                quantity = (row_data['qty'] 
                    if row_data['side'] == 'long' 
                    else - 1 * row_data['qty'])
            else:
                quantity = 0

            asset_quantities.append(quantity)
        asset_quantities = np.array(asset_quantities, dtype= np.float32)
        
        return asset_quantities


    @property
    def positions(self) -> List[float]:

        """
        The current positions of each asset held by the trader.

        Returns:
            List[float]: A list of the current positions of each asset held by the trader.
        """

        symbols = self.dataset_metadata.symbols
        positions = self.client.positions
        positions = []

        for symbol in symbols:
            row = positions[positions['symbol'] == symbol]

            if not row.empty:
                row_data = row.iloc[0]
                position = (row_data['market_value'] 
                    if row_data['side'] == 'long' 
                    else - 1 * row_data['market_value'])
            else:
                position = 0

            positions.append(position)

        return positions



    @property
    def net_worth(self):

        """
        The current net worth of the trader.

        Returns:
            float: The current net worth of the trader.
        """

        self._net_worth = self.client.account.portfolio_value

        return self._net_worth


    @property
    def longs(self):

        """
        The current long positions held by the trader.

        Returns:
            float: The current long positions held by the trader.
        """

        self._longs = self.client.account.long_market_value

        return self._longs


    @property
    def shorts(self):

        """
        The total value of all short positions held by the trader.

        Returns:
            float: The total value of all short positions held by the trader.
        """

        self._shorts = self.client.account.short_market_value

        return self._shorts


    def place_orders(self, action, *args, **kwargs):
        """
        Places orders based on the given actions.

        Args:
            action (torch.Tensor): The tensor of actions generated by the model.

        Raises:
            NotImplementedError: This method must be implemented by a subclass.
        """

        raise NotImplementedError


    def check_trade_constraints(self, *args, **kwargs):

        """
        Checks if all trade constraints are met before placing orders.

        Raises:
            TradeConstraintViolationError: If any trade constraint is violated.
        """

        # pattern day trader constraint
        patttern_day_trader = self.client.account.pattern_day_trader
        net_worth = self.net_worth

        pattern_day_trader_constraint = True if not patttern_day_trader \
            else net_worth > PATTERN_DAY_TRADER_MINIMUM_NET_WORTH

        if not pattern_day_trader_constraint:
            raise TradeConstraintViolationError(
                'Pattern day trader constraint violated.')


        # margin trading
        margin = abs(self.cash) if self.cash < 0 else 0
        maintenance_margin = 1.00

        margin_constraint = margin * maintenance_margin <= self.porftfolio_value

        if not margin_constraint:
            raise TradeConstraintViolationError(
                'Margin constraint violated.')

        return None


    def trade(self):

        """
        Starts the trading process by creating a trading environment and executing actions from the model.

        Raises:
            NotImplementedError: This method must be implemented by a subclass.
        """

        self.trade_market_env = TradeMarketEnv(trader = self)

        piped_trade_env = self.pipe(self.trade_market_env)
        observation = piped_trade_env.reset()

        while True:

            action = self.model(observation)
            observation, reward, done, info = piped_trade_env.step(action)



class CustomAlpacaTrader(AlpacaTraderTemplate):

    """
    A custom implementation of the AlpacaTraderTemplate that allows for custom order placing and rule application.

    Args:
        client (AlpacaMetaClient): An instance of the Alpaca client.
        model (nn.Module): The PyTorch model to use for trading.
        pipe (AbstractPipe): The data pipe to use for feeding the model with data.
        dataset_metadata (DatasetMetadata): The metadata for the dataset used for training the model.

    Attributes:
        client (AlpacaMetaClient): An instance of the Alpaca client.
        model (nn.Module): The PyTorch model to use for trading.
        pipe (AbstractPipe): The data pipe to use for feeding the model with data.
        dataset_metadata (DatasetMetadata): The metadata for the dataset used for training the model.

    """

    def __init__(self, 
        client: AlpacaClient, 
        model : nn.Module, 
        pipe: AbstractPipe, 
        dataset_metadata: DatasetMetadata):

        super().__init__(
            client,
            model,
            pipe,
            dataset_metadata)
    

    def apply_rules(self, *args, **kwargs):
        """
        Applies trading rules to the trades.
        Raises:
            NotImplementedError: This method must be implemented by a subclass.
        """

        raise NotImplementedError
    

    def custom(self, place_order_func):

        """
        Decorator factory that returns a new function `custom_place_order`.
        The purpose of `custom_place_order` is to wrap around a given `place_order_func` function and enforce certain 
        constraints and rules before calling it.
        
        The `check_trade_constraints` method is used to check if any trade constraints are violated, and the `apply_rules` 
        method is used to apply additional rules. Once these constraints and rules have been checked and applied, 
        `place_order_func` is called with the `action` argument.
        
        The `custom` method is designed to allow users to customize the `place_orders` method while still enforcing the 
        necessary constraints and rules. It can be used by defining a custom `place_orders` function and then decorating 
        it with `custom` to ensure that the necessary checks are performed before the orders are placed.
        """

        def custom_place_order(action):

            self.check_trade_constraints()
            self.apply_rules()

            place_order_func(action)

        return custom_place_order
    

    @custom
    def place_orders(self, action, *args, **kwargs):

        return super().place_orders(action, *args, **kwargs)