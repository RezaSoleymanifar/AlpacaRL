from __future__ import annotations
from abc import ABC, abstractmethod
from torch import nn
from typing import TYPE_CHECKING, Callable
import numpy as np

from neural.client.alpaca import AlpacaClient, AbstractTradeClient
from neural.data.enums import DatasetMetadata
from neural.train.wrapper.pipe import AbstractPipe

if TYPE_CHECKING:
    from neural.train.env import TradeMarketEnv



class AbstractTrader(ABC):

    """
    Abstract base class for defining a trader that can execute orders based on model actions.
    This trader requires a client to connect to a trading environment, a model to generate
    actions, a data pipe to feed data to the model, and metadata for the dataset being used
    to create aggregated data stream matching the training data.
    """

    def __init__(self,
        client: AbstractTradeClient,
        model: nn.Module,
        pipe: AbstractPipe,
        dataset_metadata: DatasetMetadata):

        """
        Initializes an AbstractTrader object.

        Args:
            client (AbstractClient): An instance of the client to connect to the trading environment.
            model (nn.Module): A PyTorch model used to generate actions for the trader.
            pipe (AbstractPipe): An instance of the data pipe used to feed data to the model.
            dataset_metadata (DatasetMetadata): Metadata for the dataset being used for training and validation.
        """

        self.client = client
        self.model = model
        self.pipe = pipe
        self.dataset_metadata = dataset_metadata

        return None
        

    def trade(self):

        """
        Starts the trading process by creating a trading environment and executing
        actions from the model.

        Raises:
            NotImplementedError: This method must be implemented by a subclass.
        """

        self.trade_market_env = TradeMarketEnv(trader=self)

        piped_trade_env = self.pipe(self.trade_market_env)
        observation = piped_trade_env.reset()

        while True:

            action = self.model(observation)
            observation, *_ = piped_trade_env.step(action)

    def place_orders(self, actions, *args, **kwargs):

        """
        Takes actions from the model and places relevant orders.

        Args:
            actions (np.ndarray): A 2D numpy array of actions generated by the model.

        Raises:
            NotImplementedError: This method must be implemented by a subclass.
        """
        # Get the list of symbols from the dataset metadata
        symbols = self.dataset_metadata.symbols

        # Loop over the symbols and actions and place orders for each symbol
        for symbol, action in zip(symbols, actions):
            self.client.place_order(symbol, action, *args, **kwargs)


class AlpacaTraderTemplate(AbstractTrader):

    """
    A template implementation of the AbstractTrader class for trading with the Alpaca API.
    """


    def __init__(self,
        client: AlpacaClient,
        model: nn.Module,
        pipe: AbstractPipe,
        dataset_metadata: DatasetMetadata):

        """
        Initializes an AlpacaTraderTemplate object.

        Args:
            client (AlpacaMetaClient): An instance of the Alpaca client to connect to the trading environment.
            model (nn.Module): A PyTorch model used to generate actions for the trader.
            pipe (AbstractPipe): An instance of the data pipe used to feed data to the model.
            dataset_metadata (DatasetMetadata): Metadata for the dataset being used for training and validation.
        """

        super().__init__(
            client,
            model,
            pipe,
            dataset_metadata)
    

    def place_orders(self, action, *args, **kwargs):
        
        """
        Places orders based on the given actions.

        Args:
            action (torch.Tensor): The tensor of actions generated by the model.

        Raises:
            NotImplementedError: This method must be implemented by a subclass.
        """

        raise NotImplementedError



class CustomAlpacaTrader(AlpacaTraderTemplate):

    """
    A custom implementation of the AlpacaTraderTemplate that allows for custom order placing and rule application.

    Args:
        client (AlpacaMetaClient): An instance of the Alpaca client.
        model (nn.Module): The PyTorch model to use for trading.
        pipe (AbstractPipe): The data pipe to use for feeding the model with data.
        dataset_metadata (DatasetMetadata): The metadata for the dataset used for training the model.

    Attributes:
        client (AlpacaMetaClient): An instance of the Alpaca client.
        model (nn.Module): The PyTorch model to use for trading.
        pipe (AbstractPipe): The data pipe to use for feeding the model with data.
        dataset_metadata (DatasetMetadata): The metadata for the dataset used for training the model.

    """

    def __init__(self, 
        client: AlpacaClient, 
        model : nn.Module, 
        pipe: AbstractPipe, 
        dataset_metadata: DatasetMetadata):

        super().__init__(
            client,
            model,
            pipe,
            dataset_metadata)
    

    @abstractmethod
    def apply_rules(self, *args, **kwargs):

        """
        Applies trading rules to the trades. Override this method to apply custom rules
        before placing orders. This allows rule based trading to complement the model based
        trading. For example, a rule could be to only buy a stock if it has a positive
        sentiment score. Or execute a techinical analysis strategy whenever a condition is met
        to override the normal behavior of the model.

        Raises:
            NotImplementedError: This method must be implemented by a subclass.
        """

        raise NotImplementedError
    

    def custom(self, place_orders_func: Callable):

        """
        Decorator factory that returns a new function `custom_place_order`.
        The purpose of `custom_place_order` is to wrap around a given `place_order_func` function and enforce certain 
        constraints and rules before calling it.
        
        The `check_trade_constraints` method is used to check if any trade constraints are violated, and the `apply_rules` 
        method is used to apply additional rules. Once these constraints and rules have been checked and applied, 
        `place_order_func` is called with the `action` argument.
        
        The `custom` method is designed to allow users to customize the `place_orders` method while still enforcing the 
        necessary constraints and rules. It can be used by defining a custom `place_orders` function and then decorating 
        it with `custom` to ensure that the necessary checks are performed before the orders are placed.
        """

        def custom_place_order(action):

            self.check_trade_constraints()

            try:
                self.apply_rules()

            except NotImplementedError:
                pass

            place_orders_func(action)

        return custom_place_order
    

    @custom
    def place_orders(self, action, *args, **kwargs):

        return super().place_orders(action, *args, **kwargs)